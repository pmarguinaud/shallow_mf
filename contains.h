SUBROUTINE SETALLI1 (KALL)

INTEGER (KIND=JPIM) ATTR_ARG, POINTER :: KALL (:,:)
INTEGER (KIND=JPIM), POINTER :: K (:)
INTEGER :: JLON, JLON1, IBL1, IBL1R, IGP
INTEGER (KIND=JPIM), ALLOCATABLE :: JJ1 (:)

CALL LOAD (ILUN_IN, K)

IF (IBL == 1) THEN
  ALLOCATE (KALL (KLON1, ICOUNT1))
ENDIF

DO JLON = 1, IFDIA (IBL)
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    KALL (JLON1, IBL1) = K(JLON)
  ENDIF
ENDDO
DO JLON = IFDIA (IBL)+1, KLON
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    KALL (JLON1, IBL1) = K (IFDIA (IBL))
  ENDIF
ENDDO

IF (IBL == ICOUNT) THEN
  ALLOCATE (JJ1 (KLON1))
  IGP = IBL * KLON
  IBL1R = (IGP - 1) / KLON1
  DO IBL1 = IBL1R + 1, ICOUNT1
    JJ1 (:) = KALL (:, 1 + MODULO (IBL1, IBL1R))
    KALL (:, IBL1) = JJ1 (:)
  ENDDO
  DEALLOCATE (JJ1)
ENDIF

DEALLOCATE (K)
NULLIFY (K)

END SUBROUTINE

SUBROUTINE SETALLI2 (KALL)

INTEGER (KIND=JPIM) ATTR_ARG, POINTER :: KALL (:,:,:)
INTEGER (KIND=JPIM), POINTER :: K (:,:)
INTEGER :: KLB (2), KUB (2), JLON, JLON1, IBL1R, IBL1, IGP
INTEGER (KIND=JPIM), ALLOCATABLE :: JJ2 (:,:)

CALL LOAD (ILUN_IN, K)

KLB = LBOUND (K)
KUB = UBOUND (K)

IF (IBL == 1) THEN
  ALLOCATE (KALL (KLON1, KLB (2):KUB (2), ICOUNT1))
ENDIF

DO JLON = 1, IFDIA (IBL)
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    KALL (JLON1,:,IBL1) = K (JLON, :)
  ENDIF
ENDDO
DO JLON = IFDIA (IBL)+1, KLON
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    KALL (JLON1,:,IBL1) = K (IFDIA (IBL), :)
  ENDIF
ENDDO

IF (IBL == ICOUNT) THEN
  ALLOCATE (JJ2 (KLON1, KLB (2):KUB (2)))
  IGP = IBL * KLON
  IBL1R = (IGP - 1) / KLON1
  DO IBL1 = IBL1R + 1, ICOUNT1
    JJ2 (:,:) = KALL (:,:,1 + MODULO (IBL1, IBL1R))
    KALL (:,:,IBL1) = JJ2 (:,:)
  ENDDO
  DEALLOCATE (JJ2)
ENDIF

DEALLOCATE (K)
NULLIFY (K)

END SUBROUTINE

SUBROUTINE SETALLX1 (PALL, LDPROMA)

REAL (KIND=JPRB) ATTR_ARG, POINTER :: PALL (:,:)
REAL (KIND=JPRB), POINTER :: P (:)
LOGICAL, OPTIONAL :: LDPROMA
INTEGER :: KLB (1), KUB (1), JLON, JLON1, IBL1, IBL1R, IGP
REAL (KIND=JPRB), ALLOCATABLE :: ZZ1 (:)
LOGICAL :: LLPROMA

LLPROMA = .TRUE.
IF (PRESENT (LDPROMA)) LLPROMA = LDPROMA

CALL LOAD (ILUN_IN, P)

IF (LLPROMA) THEN

  IF (IBL == 1) THEN
    ALLOCATE (PALL (KLON1, ICOUNT1))
  ENDIF

  DO JLON = 1, IFDIA (IBL)
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      PALL (JLON1, IBL1) = P (JLON)
    ENDIF
  ENDDO
  DO JLON = IFDIA (IBL)+1, KLON
    IGP = JLON + (IBL - 1) * KLON
    IBL1 = 1 + (IGP - 1) / KLON1
    JLON1 = 1 + MODULO (IGP - 1, KLON1)
    IF (IBL1 <= ICOUNT1) THEN
      PALL (JLON1, IBL1) = P (IFDIA (IBL))
    ENDIF
  ENDDO

  IF (IBL == ICOUNT) THEN
    ALLOCATE (ZZ1 (KLON1))
    IGP = IBL * KLON
    IBL1R = (IGP - 1) / KLON1
    DO IBL1 = IBL1R + 1, ICOUNT1
      ZZ1 (:) = PALL (:, 1 + MODULO (IBL1, IBL1R))
      PALL (:, IBL1) = ZZ1 (:)
    ENDDO
    DEALLOCATE (ZZ1)
  ENDIF

ELSE

  KLB = LBOUND (P)
  KUB = UBOUND (P)

  IF (IBL == 1) THEN
    ALLOCATE (PALL (KLB (1):KUB (1), ICOUNT1))
  ENDIF

  PALL (:,1) = P

  IF (IBL == ICOUNT) THEN
    ALLOCATE (ZZ1 (KLB (1):KUB (1)))
    DO IBL1 = 2, ICOUNT1
      ZZ1 (:) = PALL (:,1)
      PALL (:,IBL1) = ZZ1 (:)
    ENDDO
    DEALLOCATE (ZZ1)
  ENDIF

ENDIF

DEALLOCATE (P)
NULLIFY (P)

END SUBROUTINE

SUBROUTINE SETALLX2 (PALL)

REAL (KIND=JPRB) ATTR_ARG, POINTER :: PALL (:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:)
INTEGER :: KLB (2), KUB (2), JLON, JLON1, IBL1R, IBL1, IGP
REAL (KIND=JPRB), ALLOCATABLE :: ZZ2 (:,:)

CALL LOAD (ILUN_IN, P)

KLB = LBOUND (P)
KUB = UBOUND (P)

IF (IBL == 1) THEN
  ALLOCATE (PALL (KLON1, KLB (2):KUB (2), ICOUNT1))
ENDIF

DO JLON = 1, IFDIA (IBL)
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    PALL (JLON1, :, IBL1) = P (JLON, :)
  ENDIF
ENDDO
DO JLON = IFDIA (IBL)+1, KLON
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    PALL (JLON1, :, IBL1) = P (IFDIA (IBL), :)
  ENDIF
ENDDO

IF (IBL == ICOUNT) THEN
  ALLOCATE (ZZ2 (KLON1, KLB (2):KUB (2)))
  IGP = IBL * KLON
  IBL1R = (IGP - 1) / KLON1
  DO IBL1 = IBL1R + 1, ICOUNT1
    ZZ2 (:,:) = PALL (:, :, 1 + MODULO (IBL1, IBL1R))
    PALL (:, :, IBL1) = ZZ2 (:,:)
  ENDDO
  DEALLOCATE (ZZ2)
ENDIF

DEALLOCATE (P)
NULLIFY (P)

END SUBROUTINE

SUBROUTINE SETALLX3 (PALL)

REAL (KIND=JPRB) ATTR_ARG, POINTER :: PALL (:,:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:,:)
INTEGER :: KLB (3), KUB (3), JLON, JLON1, IBL1R, IBL1, IGP
REAL (KIND=JPRB), ALLOCATABLE :: ZZ3 (:,:,:)

CALL LOAD (ILUN_IN, P)

KLB = LBOUND (P)
KUB = UBOUND (P)

IF (IBL == 1) THEN
  ALLOCATE (PALL (KLON1, KLB (2):KUB (2), KLB (3):KUB (3), ICOUNT1))
ENDIF

DO JLON = 1, IFDIA (IBL)
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    PALL (JLON1, :, :, IBL1) = P (JLON, :, :)
  ENDIF
ENDDO
DO JLON = IFDIA (IBL)+1, KLON
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    PALL (JLON1, :, :, IBL1) = P (IFDIA (IBL), :, :)
  ENDIF
ENDDO

IF (IBL == ICOUNT) THEN
  ALLOCATE (ZZ3 (KLON1, KLB (2):KUB (2), KLB (3):KUB (3)))
  IGP = IBL * KLON
  IBL1R = (IGP - 1) / KLON1
  DO IBL1 = IBL1R + 1, ICOUNT1
    ZZ3 (:,:,:) = PALL (:, :, :, 1 + MODULO (IBL1, IBL1R))
    PALL (:, :, :, IBL1) = ZZ3 (:,:,:)
  ENDDO
  DEALLOCATE (ZZ3)
ENDIF

DEALLOCATE (P)
NULLIFY (P)

END SUBROUTINE

SUBROUTINE SETALLX4 (PALL)

REAL (KIND=JPRB) ATTR_ARG, POINTER :: PALL (:,:,:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:,:,:)
INTEGER :: KLB (4), KUB (4), JLON, JLON1, IBL1R, IBL1, IGP
REAL (KIND=JPRB), ALLOCATABLE :: ZZ4 (:,:,:,:)

CALL LOAD (ILUN_IN, P)

KLB = LBOUND (P)
KUB = UBOUND (P)

IF (IBL == 1) THEN
  ALLOCATE (PALL (KLON1, KLB (2):KUB (2), KLB (3):KUB (3), KLB (4):KUB (4), ICOUNT1))
ENDIF

DO JLON = 1, IFDIA (IBL)
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    PALL (JLON1, :, :, :, IBL1) = P (JLON, :, :, :)
  ENDIF
ENDDO
DO JLON = IFDIA (IBL)+1, KLON
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    PALL (JLON1, :, :, :, IBL1) = P (IFDIA (IBL), :, :, :)
  ENDIF
ENDDO

IF (IBL == ICOUNT) THEN
  ALLOCATE (ZZ4 (KLON1, KLB (2):KUB (2), KLB (3):KUB (3), KLB (4):KUB (4)))
  IGP = IBL * KLON
  IBL1R = (IGP - 1) / KLON1
  DO IBL1 = IBL1R + 1, ICOUNT1
    ZZ4 (:,:,:,:) = PALL (:, :, :, :, 1 + MODULO (IBL1, IBL1R))
    PALL (:, :, :, :, IBL1) = ZZ4 (:,:,:,:)
  ENDDO
  DEALLOCATE (ZZ4)
ENDIF

DEALLOCATE (P)
NULLIFY (P)

END SUBROUTINE

SUBROUTINE SETALLL3 (PALL)

LOGICAL ATTR_ARG, POINTER :: PALL (:,:,:,:)
LOGICAL, POINTER :: P (:,:,:)
INTEGER :: KLB (3), KUB (3), JLON, JLON1, IBL1R, IBL1, IGP
LOGICAL, ALLOCATABLE :: ZZ3 (:,:,:)

CALL LOAD (ILUN_IN, P)

KLB = LBOUND (P)
KUB = UBOUND (P)

IF (IBL == 1) THEN
  ALLOCATE (PALL (KLON1, KLB (2):KUB (2), KLB (3):KUB (3), ICOUNT1))
ENDIF

DO JLON = 1, IFDIA (IBL)
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    PALL (JLON1, :, :, IBL1) = P (JLON, :, :)
  ENDIF
ENDDO
DO JLON = IFDIA (IBL)+1, KLON
  IGP = JLON + (IBL - 1) * KLON
  IBL1 = 1 + (IGP - 1) / KLON1
  JLON1 = 1 + MODULO (IGP - 1, KLON1)
  IF (IBL1 <= ICOUNT1) THEN
    PALL (JLON1, :, :, IBL1) = P (IFDIA (IBL), :, :)
  ENDIF
ENDDO

IF (IBL == ICOUNT) THEN
  ALLOCATE (ZZ3 (KLON1, KLB (2):KUB (2), KLB (3):KUB (3)))
  IGP = IBL * KLON
  IBL1R = (IGP - 1) / KLON1
  DO IBL1 = IBL1R + 1, ICOUNT1
    ZZ3 (:,:,:) = PALL (:, :, :, 1 + MODULO (IBL1, IBL1R))
    PALL (:, :, :, IBL1) = ZZ3 (:,:,:)
  ENDDO
  DEALLOCATE (ZZ3)
ENDIF

DEALLOCATE (P)
NULLIFY (P)

END SUBROUTINE

SUBROUTINE DDIFFX1 (CDNAME, PALL, LDPRINT)

CHARACTER(LEN=*) :: CDNAME
LOGICAL :: LDPRINT
REAL (KIND=JPRB) ATTR_ARG :: PALL (:,:)
REAL (KIND=JPRB), POINTER :: P (:)
REAL (KIND=JPRB), POINTER :: ZALL (:)

CALL LOAD (ILUN_OUT, P)

IF (KFDIA == IFDIA (IBL) .AND. LDPRINT) THEN
  ALLOCATE (ZALL (LBOUND (PALL, 1):UBOUND (PALL, 1)))
  ZALL = PALL (:, IBL)
  CALL DIFF (CDNAME, ZALL, P)
  DEALLOCATE (ZALL)
ENDIF

DEALLOCATE (P)

END SUBROUTINE

SUBROUTINE DDIFFX2 (CDNAME, PALL, LDPRINT)

CHARACTER(LEN=*) :: CDNAME
LOGICAL :: LDPRINT
REAL (KIND=JPRB) ATTR_ARG :: PALL (:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:)
REAL (KIND=JPRB), POINTER :: ZALL (:,:)

CALL LOAD (ILUN_OUT, P)

IF (KFDIA == IFDIA (IBL) .AND. LDPRINT) THEN
  ALLOCATE (ZALL (LBOUND (PALL, 1):UBOUND (PALL, 1), LBOUND (PALL, 2):UBOUND (PALL, 2)))
  ZALL = PALL (:,:,IBL)
  CALL DIFF (CDNAME, ZALL, P)
  DEALLOCATE (ZALL)
ENDIF

DEALLOCATE (P)

END SUBROUTINE

SUBROUTINE DDIFFX3 (CDNAME, PALL, LDPRINT)

CHARACTER(LEN=*) :: CDNAME
LOGICAL :: LDPRINT
REAL (KIND=JPRB) ATTR_ARG :: PALL (:,:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:,:)
REAL (KIND=JPRB), POINTER :: ZALL (:,:,:)

CALL LOAD (ILUN_OUT, P)

IF (KFDIA == IFDIA (IBL) .AND. LDPRINT) THEN
  ALLOCATE (ZALL (LBOUND (PALL, 1):UBOUND (PALL, 1), &
                  LBOUND (PALL, 2):UBOUND (PALL, 2), &
                  LBOUND (PALL, 3):UBOUND (PALL, 3)))
  ZALL = PALL (:, :, :, IBL)
  CALL DIFF (CDNAME, ZALL, P)
  DEALLOCATE (ZALL)
ENDIF

DEALLOCATE (P)

END SUBROUTINE

SUBROUTINE DDIFFX4 (CDNAME, PALL, LDPRINT)

CHARACTER(LEN=*) :: CDNAME
LOGICAL :: LDPRINT
REAL (KIND=JPRB) ATTR_ARG :: PALL (:,:,:,:,:)
REAL (KIND=JPRB), POINTER :: P (:,:,:,:)
REAL (KIND=JPRB), POINTER :: ZALL (:,:,:,:)

CALL LOAD (ILUN_OUT, P)

IF (KFDIA == IFDIA (IBL) .AND. LDPRINT) THEN
  ALLOCATE (ZALL (LBOUND (PALL, 1):UBOUND (PALL, 1), &
                  LBOUND (PALL, 2):UBOUND (PALL, 2), &
                  LBOUND (PALL, 3):UBOUND (PALL, 3), &
                  LBOUND (PALL, 4):UBOUND (PALL, 4)))
  ZALL = PALL (:, :, :, :, IBL)
  CALL DIFF (CDNAME, ZALL, P)
  DEALLOCATE (ZALL)
ENDIF

DEALLOCATE (P)

END SUBROUTINE



